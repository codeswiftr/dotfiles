#!/bin/bash

# Dotfiles Commit Message Hook
# Validates commit message format and content

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
HOOKS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$HOOKS_DIR/.." && pwd)"
COMMIT_MSG_FILE="$1"

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_error() {
    echo -e "${RED}[FAIL]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Validation functions
validate_commit_message() {
    local commit_msg
    commit_msg=$(cat "$COMMIT_MSG_FILE")
    
    # Skip merge commits
    if [[ "$commit_msg" =~ ^Merge.* ]]; then
        log_info "Merge commit detected, skipping validation"
        return 0
    fi
    
    # Skip revert commits
    if [[ "$commit_msg" =~ ^Revert.* ]]; then
        log_info "Revert commit detected, skipping validation"
        return 0
    fi
    
    # Check for minimum length
    if [[ ${#commit_msg} -lt 10 ]]; then
        log_error "Commit message too short (minimum 10 characters)"
        echo "Current message: '$commit_msg'"
        return 1
    fi
    
    # Check for maximum length of first line
    local first_line
    first_line=$(echo "$commit_msg" | head -n1)
    if [[ ${#first_line} -gt 72 ]]; then
        log_error "First line too long (maximum 72 characters)"
        echo "Current length: ${#first_line}"
        echo "First line: '$first_line'"
        return 1
    fi
    
    # Check for conventional commit format
    local conventional_types=(
        "feat"      # New feature
        "fix"       # Bug fix
        "docs"      # Documentation
        "style"     # Code style (formatting, etc.)
        "refactor"  # Code refactoring
        "test"      # Tests
        "chore"     # Maintenance
        "perf"      # Performance improvement
        "ci"        # CI/CD changes
        "build"     # Build system changes
        "revert"    # Revert changes
    )
    
    local is_conventional=false
    for type in "${conventional_types[@]}"; do
        if [[ "$first_line" =~ ^$type(\(.+\))?:\ .+ ]]; then
            is_conventional=true
            break
        fi
    done
    
    if [[ "$is_conventional" == "true" ]]; then
        log_success "Commit message follows conventional format"
    else
        log_warning "Commit message should follow conventional format"
        echo "Expected format: type(scope): description"
        echo "Types: ${conventional_types[*]}"
        echo "Examples:"
        echo "  feat: add new installation method"
        echo "  fix: resolve shell startup issue"
        echo "  docs: update README installation guide"
        echo "  refactor(cli): simplify command structure"
        echo ""
        echo "Current message: '$first_line'"
        echo ""
        echo "Consider updating your commit message to follow conventions."
        echo "This is a warning - the commit will still proceed."
    fi
    
    # Check for proper capitalization
    local description_part
    description_part=$(echo "$first_line" | sed 's/^[a-z]*(\?[^)]*\)\?:\ //')
    if [[ "$description_part" =~ ^[A-Z] ]]; then
        log_warning "Description should start with lowercase letter"
        echo "Current: '$description_part'"
        echo "Consider: '$(echo "$description_part" | sed 's/^./\L&/')"
    fi
    
    # Check for ending punctuation
    if [[ "$first_line" =~ [.!?]$ ]]; then
        log_warning "First line should not end with punctuation"
        echo "Current: '$first_line'"
    fi
    
    # Check for imperative mood hints
    local imperative_violations=(
        "added"
        "changed"
        "fixed"
        "removed"
        "updated"
        "created"
        "deleted"
        "modified"
    )
    
    for violation in "${imperative_violations[@]}"; do
        if [[ "$description_part" =~ ^$violation ]]; then
            log_warning "Use imperative mood (e.g., 'add' not 'added')"
            echo "Current: '$description_part'"
            local suggestion
            suggestion=$(echo "$violation" | sed 's/ed$//' | sed 's/d$//')
            echo "Consider: '$(echo "$description_part" | sed "s/^$violation/$suggestion/")'"
            break
        fi
    done
    
    # Check for Co-authored-by trailer
    if [[ "$commit_msg" == *"Co-Authored-By: Claude"* ]]; then
        log_info "Claude co-authorship detected"
    fi
    
    # Check for GitHub issue references
    if [[ "$commit_msg" =~ \#[0-9]+ ]]; then
        log_info "GitHub issue reference detected"
    fi
    
    # Check for breaking changes
    if [[ "$commit_msg" == *"BREAKING CHANGE"* ]] || [[ "$first_line" =~ \!\: ]]; then
        log_warning "Breaking change detected - ensure proper documentation"
    fi
    
    log_success "Commit message validation completed"
    return 0
}

# Main execution
main() {
    log_info "Validating commit message..."
    
    if [[ ! -f "$COMMIT_MSG_FILE" ]]; then
        log_error "Commit message file not found: $COMMIT_MSG_FILE"
        exit 1
    fi
    
    if validate_commit_message; then
        log_success "Commit message is acceptable"
        exit 0
    else
        log_error "Commit message validation failed"
        echo ""
        echo "Please update your commit message and try again."
        echo "Use: git commit --amend -m 'your new message'"
        exit 1
    fi
}

# Run main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi