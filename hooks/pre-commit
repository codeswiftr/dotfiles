#!/bin/bash

# Dotfiles Pre-commit Hook
# Automated quality gates for dotfiles repository

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
HOOKS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$HOOKS_DIR/.." && pwd)"
TEMP_DIR=$(mktemp -d)
EXIT_CODE=0

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_error() {
    echo -e "${RED}[FAIL]${NC} $1"
    EXIT_CODE=1
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Security checks
check_sensitive_data() {
    log_info "Checking for sensitive data..."

    # More precise patterns to reduce false positives
    # Looks for assignments or JSON/YAML style mappings
    local -a patterns=(
        'password\s*[:=]'
        'secret\s*[:=]'
        'token\s*[:=]'
        'api[_-]?key\s*[:=]'
        'access[_-]?key\s*[:=]'
        'auth[_-]?token\s*[:=]'
        'private[_-]?key'
        'ssh[_-]?key'
        'client[_-]?secret\s*[:=]'
    )

    local found_sensitive=false

    # Only scan staged files that are text and not in ignored paths
    while IFS= read -r file; do
        [[ ! -f "$file" ]] && continue
        # Ignore docs, tests, and markdown files
        if [[ "$file" == docs/* || "$file" == tests/* || "$file" == *.md ]]; then
            continue
        fi
        # Skip known example/template files
        if grep -qiE '(example|sample|template)' <<<"$file"; then
            continue
        fi
        # Use ripgrep if available for better performance
        if command -v rg >/dev/null 2>&1; then
            for pat in "${patterns[@]}"; do
                if rg -n -i -e "$pat" -- "$file" | rg -v "# (Example|Template|Test)" >/dev/null; then
                    log_error "Potential sensitive data found in $file (pattern: $pat)"
                    found_sensitive=true
                fi
            done
        else
            for pat in "${patterns[@]}"; do
                if grep -nEi "$pat" "$file" | grep -vE "# (Example|Template|Test)" >/dev/null; then
                    log_error "Potential sensitive data found in $file (pattern: $pat)"
                    found_sensitive=true
                fi
            done
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)

    if [[ "$found_sensitive" == "false" ]]; then
        log_success "No sensitive data detected"
    fi
}

# Syntax checks
check_shell_syntax() {
    log_info "Checking shell script syntax..."

    local syntax_errors=false

    while IFS= read -r file; do
        [[ ! -f "$file" ]] && continue
        [[ ! "$file" =~ \.(sh|zsh|bash)$ ]] && continue

        # Detect interpreter by shebang or extension
        local shebang
        shebang=$(head -1 "$file" 2>/dev/null || true)

        if [[ "$shebang" == *"osascript"* ]]; then
            # Not a shell script
            continue
        elif [[ "$shebang" == *"zsh"* || "$file" == *.zsh ]]; then
            if command -v zsh >/dev/null 2>&1; then
                if ! zsh -n "$file" 2>/dev/null; then
                    log_error "Zsh syntax error: $file"
                    syntax_errors=true
                fi
            fi
        else
            if ! bash -n "$file" 2>/dev/null; then
                log_error "Bash syntax error: $file"
                syntax_errors=true
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)

    if [[ "$syntax_errors" == "false" ]]; then
        log_success "Shell script syntax is valid"
    fi
}

check_yaml_syntax() {
    log_info "Checking YAML syntax..."
    
    local yaml_errors=false
    
    # Check staged YAML files
    while IFS= read -r file; do
        if [[ "$file" =~ \.(yaml|yml)$ ]] && [[ -f "$file" ]]; then
            if command -v python3 >/dev/null 2>&1; then
                if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
                    log_error "YAML syntax error in: $file"
                    yaml_errors=true
                fi
            elif command -v yamllint >/dev/null 2>&1; then
                if ! yamllint "$file" >/dev/null 2>&1; then
                    log_error "YAML syntax error in: $file"
                    yaml_errors=true
                fi
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)
    
    if [[ "$yaml_errors" == "false" ]]; then
        log_success "YAML syntax is valid"
    fi
}

# Code quality checks
check_dangerous_commands() {
    log_info "Checking for dangerous commands..."

    # Safer patterns: explicit pipe-to-shell and destructive rm/chmod
    local -a dangerous_patterns=(
        'rm\s+-rf\s+/'
        'sudo\s+rm\s+-rf\s+'
        'chmod\s+777\b'
        '(curl|wget).*(\|\s*)(bash|sh|zsh)\b'
        '(bash|sh)\s+-c\s+"\$\(curl|wget'
        'eval\s+\$\('
    )

    local found_dangerous=false

    while IFS= read -r file; do
        [[ ! -f "$file" ]] && continue
        if command -v rg >/dev/null 2>&1; then
            for pat in "${dangerous_patterns[@]}"; do
                if rg -n -E "$pat" -- "$file" | rg -v "# (Safe|Example)" >/dev/null; then
                    log_error "Dangerous command pattern found in $file (pattern: $pat)"
                    found_dangerous=true
                fi
            done
        else
            for pat in "${dangerous_patterns[@]}"; do
                if grep -nE "$pat" "$file" | grep -vE "# (Safe|Example)" >/dev/null; then
                    log_error "Dangerous command pattern found in $file (pattern: $pat)"
                    found_dangerous=true
                fi
            done
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)

    if [[ "$found_dangerous" == "false" ]]; then
        log_success "No dangerous commands detected"
    fi
}

check_file_permissions() {
    log_info "Checking file permissions..."

    local permission_errors=false

    # Only require executability for scripts with a shebang
    while IFS= read -r file; do
        [[ ! -f "$file" ]] && continue
        # Check common script extensions
        if [[ "$file" =~ \.(sh|zsh|bash)$ ]]; then
            local first
            first=$(head -1 "$file" 2>/dev/null || true)
            if [[ "$first" == "#!"* ]]; then
                if [[ ! -x "$file" ]]; then
                    log_error "Script with shebang should be executable: $file"
                    permission_errors=true
                fi
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)

    if [[ "$permission_errors" == "false" ]]; then
        log_success "File permissions are correct"
    fi
}

# Configuration validation
validate_dotfiles_structure() {
    log_info "Validating dotfiles structure..."
    
    # Skip if not in dotfiles repository
    if [[ ! -f "install.sh" ]] && [[ ! -f "install-declarative.sh" ]]; then
        log_info "Skipping structure validation (not a dotfiles repository)"
        return 0
    fi
    
    local structure_errors=false
    
    # Check for installer (flexible naming)
    if [[ ! -f "install.sh" ]] && [[ ! -f "install-declarative.sh" ]]; then
        log_error "No installer script found (install.sh or install-declarative.sh)"
        structure_errors=true
    fi
    
    # Check for optional but recommended files
    local optional_files=(
        "config/tools.yaml"
        "lib/cli/core.sh"
        "scripts/health-check.sh"
        "VERSION"
    )
    
    for file in "${optional_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            log_warning "Recommended file missing: $file"
        fi
    done
    
    # Check for core directories
    local core_dirs=(
        "config"
    )
    
    for dir in "${core_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log_error "Core directory missing: $dir"
            structure_errors=true
        fi
    done
    
    # Check for optional directories
    local optional_dirs=(
        "lib"
        "scripts"
        "tests"
    )
    
    for dir in "${optional_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log_warning "Recommended directory missing: $dir"
        fi
    done
    
    if [[ "$structure_errors" == "false" ]]; then
        log_success "Dotfiles structure is valid"
    fi
}

# Testing
run_quick_tests() {
    log_info "Running quick tests..."
    
    # Run basic installation test
    if [[ -f "tests/infrastructure/test_installation.sh" ]]; then
        if timeout 30 ./tests/infrastructure/test_installation.sh >/dev/null 2>&1; then
            log_success "Quick installation test passed"
        else
            log_error "Quick installation test failed"
        fi
    else
        log_warning "Installation test not found"
    fi
    
    # Test installer dry run
    if [[ -f "install.sh" ]]; then
        if timeout 30 ./install.sh --dry-run profiles >/dev/null 2>&1; then
            log_success "Installer dry run test passed"
        else
            log_error "Installer dry run test failed"
        fi
    else
        log_error "install.sh not found"
    fi
}

# Index consistency
validate_index_consistency() {
    log_info "Validating docs index consistency..."
    if [[ -x "scripts/generate-index.sh" ]]; then
        # Run generator and see if index changes
        before_hash_md=$(md5 -q docs/INDEX.md 2>/dev/null || md5sum docs/INDEX.md | awk '{print $1}' || true)
        before_hash_json=$(md5 -q docs/index.json 2>/dev/null || md5sum docs/index.json | awk '{print $1}' || true)
        bash scripts/generate-index.sh >/dev/null 2>&1 || true
        after_hash_md=$(md5 -q docs/INDEX.md 2>/dev/null || md5sum docs/INDEX.md | awk '{print $1}' || true)
        after_hash_json=$(md5 -q docs/index.json 2>/dev/null || md5sum docs/index.json | awk '{print $1}' || true)
        if [[ "$before_hash_md" != "$after_hash_md" || "$before_hash_json" != "$after_hash_json" ]]; then
            log_error "Docs index out of date. Please run scripts/generate-index.sh and re-commit."
        else
            log_success "Docs index is up to date"
        fi
    else
        log_warning "Index generator not found; skipping index validation"
    fi
}

# Help snapshot freshness
validate_help_snapshots() {
    log_info "Validating CLI help snapshots..."
    if [[ -x "scripts/capture-cli-help.sh" ]]; then
        local before_hash
        before_hash=$(tar -cf - src/--help 2>/dev/null | shasum | awk '{print $1}' || echo "")
        bash scripts/capture-cli-help.sh >/dev/null 2>&1 || true
        local after_hash
        after_hash=$(tar -cf - src/--help 2>/dev/null | shasum | awk '{print $1}' || echo "")
        if [[ "$before_hash" != "$after_hash" ]]; then
            log_error "Help snapshots out of date. Run scripts/capture-cli-help.sh and commit."
        else
            log_success "Help snapshots are up to date"
        fi
    else
        log_warning "Help capture script not found; skipping help validation"
    fi
}

# Version check
check_version_consistency() {
    log_info "Checking version consistency..."
    
    if [[ -f "VERSION" ]] && [[ -f "lib/version.sh" ]]; then
        local version_file_content
        version_file_content=$(cat VERSION)
        
        if grep -q "$version_file_content" lib/version.sh; then
            log_success "Version consistency check passed"
        else
            log_error "Version mismatch between VERSION file and lib/version.sh"
        fi
    else
        log_warning "Version files not found"
    fi
}

# Commit message validation
validate_commit_message() {
    log_info "Validating commit message format..."
    
    local commit_msg_file="$1"
    local commit_msg
    
    if [[ -f "$commit_msg_file" ]]; then
        commit_msg=$(cat "$commit_msg_file")
        
        # Check for minimum length
        if [[ ${#commit_msg} -lt 10 ]]; then
            log_error "Commit message too short (minimum 10 characters)"
            return 1
        fi
        
        # Check for proper format (type: description)
        if [[ "$commit_msg" =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(:|\() ]]; then
            log_success "Commit message format is valid"
        else
            log_warning "Commit message should follow conventional format: type: description"
        fi
    fi
}

# Cleanup function
cleanup() {
    rm -rf "$TEMP_DIR"
}

# Main execution
main() {
    log_info "Starting dotfiles pre-commit quality gates..."
    echo
    
    # Change to repository root and verify we're in the right place
    cd "$REPO_ROOT"
    
    # Verify we're in a dotfiles repository
    if [[ ! -f "install.sh" ]] && [[ ! -f "install-declarative.sh" ]]; then
        log_warning "Not in a dotfiles repository root, skipping structure validation"
        return 0
    fi
    
    # Run security checks
    check_sensitive_data
    check_dangerous_commands
    echo
    
    # Run syntax checks
    check_shell_syntax
    check_yaml_syntax
    echo
    
    # Run code quality checks
    check_file_permissions
    validate_dotfiles_structure
    echo
    
    # Run version checks
    check_version_consistency
    echo

    # Validate docs index
    validate_index_consistency
    echo
    
    # Validate help snapshots
    validate_help_snapshots
    echo
    
    # Run quick tests
    run_quick_tests
    echo
    
    # Summary
    if [[ $EXIT_CODE -eq 0 ]]; then
        log_success "All quality gates passed! ✅"
    else
        log_error "Some quality gates failed! ❌"
        echo
        echo "Please fix the issues above before committing."
        echo "You can run individual checks manually:"
        echo "  - Security: hooks/pre-commit"
        echo "  - Tests: tests/test_runner.sh"
        echo "  - Health: scripts/health-check.sh"
    fi
    
    cleanup
    exit $EXIT_CODE
}

# Handle commit message validation if called from commit-msg hook
if [[ "${1:-}" == "--commit-msg" ]]; then
    validate_commit_message "$2"
    exit $?
fi

# Run main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi