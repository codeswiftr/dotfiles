#!/bin/bash

# Dotfiles Pre-commit Hook
# Automated quality gates for dotfiles repository

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
HOOKS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$HOOKS_DIR/.." && pwd)"
TEMP_DIR=$(mktemp -d)
EXIT_CODE=0

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_error() {
    echo -e "${RED}[FAIL]${NC} $1"
    EXIT_CODE=1
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Security checks
check_sensitive_data() {
    log_info "Checking for sensitive data..."
    
    local sensitive_patterns=(
        "password"
        "secret"
        "token"
        "api_key"
        "private_key"
        "ssh_key"
        "auth_token"
        "access_key"
        "client_secret"
    )
    
    local found_sensitive=false
    
    # Check staged files
    while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            for pattern in "${sensitive_patterns[@]}"; do
                if grep -i "$pattern" "$file" | grep -v "# Example" | grep -v "# TODO" | grep -v "# Template" >/dev/null 2>&1; then
                    log_error "Potential sensitive data found in $file: $pattern"
                    found_sensitive=true
                fi
            done
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)
    
    if [[ "$found_sensitive" == "false" ]]; then
        log_success "No sensitive data detected"
    fi
}

# Syntax checks
check_shell_syntax() {
    log_info "Checking shell script syntax..."
    
    local syntax_errors=false
    
    # Check staged shell files
    while IFS= read -r file; do
        if [[ "$file" =~ \.(sh|zsh|bash)$ ]] && [[ -f "$file" ]]; then
            if ! bash -n "$file" 2>/dev/null; then
                log_error "Syntax error in shell script: $file"
                syntax_errors=true
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)
    
    if [[ "$syntax_errors" == "false" ]]; then
        log_success "Shell script syntax is valid"
    fi
}

check_yaml_syntax() {
    log_info "Checking YAML syntax..."
    
    local yaml_errors=false
    
    # Check staged YAML files
    while IFS= read -r file; do
        if [[ "$file" =~ \.(yaml|yml)$ ]] && [[ -f "$file" ]]; then
            if command -v python3 >/dev/null 2>&1; then
                if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
                    log_error "YAML syntax error in: $file"
                    yaml_errors=true
                fi
            elif command -v yamllint >/dev/null 2>&1; then
                if ! yamllint "$file" >/dev/null 2>&1; then
                    log_error "YAML syntax error in: $file"
                    yaml_errors=true
                fi
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)
    
    if [[ "$yaml_errors" == "false" ]]; then
        log_success "YAML syntax is valid"
    fi
}

# Code quality checks
check_dangerous_commands() {
    log_info "Checking for dangerous commands..."
    
    local dangerous_patterns=(
        "rm -rf /"
        "sudo rm -rf"
        "chmod 777"
        "curl.*|.*sh"
        "wget.*|.*sh"
        "eval.*\$"
    )
    
    local found_dangerous=false
    
    # Check staged files
    while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            for pattern in "${dangerous_patterns[@]}"; do
                if grep -E "$pattern" "$file" | grep -v "# Safe:" | grep -v "# Example:" >/dev/null 2>&1; then
                    log_error "Dangerous command pattern found in $file: $pattern"
                    found_dangerous=true
                fi
            done
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)
    
    if [[ "$found_dangerous" == "false" ]]; then
        log_success "No dangerous commands detected"
    fi
}

check_file_permissions() {
    log_info "Checking file permissions..."
    
    local permission_errors=false
    
    # Check that shell scripts are executable
    while IFS= read -r file; do
        if [[ "$file" =~ \.(sh|zsh|bash)$ ]] && [[ -f "$file" ]]; then
            if [[ ! -x "$file" ]]; then
                log_error "Shell script is not executable: $file"
                permission_errors=true
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM)
    
    if [[ "$permission_errors" == "false" ]]; then
        log_success "File permissions are correct"
    fi
}

# Configuration validation
validate_dotfiles_structure() {
    log_info "Validating dotfiles structure..."
    
    # Skip if not in dotfiles repository
    if [[ ! -f "install.sh" ]] && [[ ! -f "install-declarative.sh" ]]; then
        log_info "Skipping structure validation (not a dotfiles repository)"
        return 0
    fi
    
    local structure_errors=false
    
    # Check for installer (flexible naming)
    if [[ ! -f "install.sh" ]] && [[ ! -f "install-declarative.sh" ]]; then
        log_error "No installer script found (install.sh or install-declarative.sh)"
        structure_errors=true
    fi
    
    # Check for optional but recommended files
    local optional_files=(
        "config/tools.yaml"
        "lib/cli/core.sh"
        "scripts/health-check.sh"
        "VERSION"
    )
    
    for file in "${optional_files[@]}"; do
        if [[ ! -f "$file" ]]; then
            log_warning "Recommended file missing: $file"
        fi
    done
    
    # Check for core directories
    local core_dirs=(
        "config"
    )
    
    for dir in "${core_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log_error "Core directory missing: $dir"
            structure_errors=true
        fi
    done
    
    # Check for optional directories
    local optional_dirs=(
        "lib"
        "scripts"
        "tests"
    )
    
    for dir in "${optional_dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            log_warning "Recommended directory missing: $dir"
        fi
    done
    
    if [[ "$structure_errors" == "false" ]]; then
        log_success "Dotfiles structure is valid"
    fi
}

# Testing
run_quick_tests() {
    log_info "Running quick tests..."
    
    # Run basic installation test
    if [[ -f "tests/infrastructure/test_installation.sh" ]]; then
        if timeout 30 ./tests/infrastructure/test_installation.sh >/dev/null 2>&1; then
            log_success "Quick installation test passed"
        else
            log_error "Quick installation test failed"
        fi
    else
        log_warning "Installation test not found"
    fi
    
    # Test installer dry run
    if [[ -f "install.sh" ]]; then
        if timeout 30 ./install.sh --dry-run profiles >/dev/null 2>&1; then
            log_success "Installer dry run test passed"
        else
            log_error "Installer dry run test failed"
        fi
    else
        log_error "install.sh not found"
    fi
}

# Version check
check_version_consistency() {
    log_info "Checking version consistency..."
    
    if [[ -f "VERSION" ]] && [[ -f "lib/version.sh" ]]; then
        local version_file_content
        version_file_content=$(cat VERSION)
        
        if grep -q "$version_file_content" lib/version.sh; then
            log_success "Version consistency check passed"
        else
            log_error "Version mismatch between VERSION file and lib/version.sh"
        fi
    else
        log_warning "Version files not found"
    fi
}

# Commit message validation
validate_commit_message() {
    log_info "Validating commit message format..."
    
    local commit_msg_file="$1"
    local commit_msg
    
    if [[ -f "$commit_msg_file" ]]; then
        commit_msg=$(cat "$commit_msg_file")
        
        # Check for minimum length
        if [[ ${#commit_msg} -lt 10 ]]; then
            log_error "Commit message too short (minimum 10 characters)"
            return 1
        fi
        
        # Check for proper format (type: description)
        if [[ "$commit_msg" =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(:|\() ]]; then
            log_success "Commit message format is valid"
        else
            log_warning "Commit message should follow conventional format: type: description"
        fi
    fi
}

# Cleanup function
cleanup() {
    rm -rf "$TEMP_DIR"
}

# Main execution
main() {
    log_info "Starting dotfiles pre-commit quality gates..."
    echo
    
    # Change to repository root and verify we're in the right place
    cd "$REPO_ROOT"
    
    # Verify we're in a dotfiles repository
    if [[ ! -f "install.sh" ]] && [[ ! -f "install-declarative.sh" ]]; then
        log_warning "Not in a dotfiles repository root, skipping structure validation"
        return 0
    fi
    
    # Run security checks
    check_sensitive_data
    check_dangerous_commands
    echo
    
    # Run syntax checks
    check_shell_syntax
    check_yaml_syntax
    echo
    
    # Run code quality checks
    check_file_permissions
    validate_dotfiles_structure
    echo
    
    # Run version checks
    check_version_consistency
    echo
    
    # Run quick tests
    run_quick_tests
    echo
    
    # Summary
    if [[ $EXIT_CODE -eq 0 ]]; then
        log_success "All quality gates passed! ✅"
    else
        log_error "Some quality gates failed! ❌"
        echo
        echo "Please fix the issues above before committing."
        echo "You can run individual checks manually:"
        echo "  - Security: hooks/pre-commit"
        echo "  - Tests: tests/test_runner.sh"
        echo "  - Health: scripts/health-check.sh"
    fi
    
    cleanup
    exit $EXIT_CODE
}

# Handle commit message validation if called from commit-msg hook
if [[ "${1:-}" == "--commit-msg" ]]; then
    validate_commit_message "$2"
    exit $?
fi

# Run main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi