#!/bin/bash

# Dotfiles Pre-push Hook
# Comprehensive validation before pushing to remote

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
HOOKS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$HOOKS_DIR/.." && pwd)"
remote="$1"
url="$2"
EXIT_CODE=0

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_error() {
    echo -e "${RED}[FAIL]${NC} $1"
    EXIT_CODE=1
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Validation functions
run_comprehensive_tests() {
    log_info "Running comprehensive test suite..."
    
    # Check if test runner exists
    if [[ ! -f "tests/test_runner.sh" ]]; then
        log_warning "Test runner not found, skipping tests"
        return 0
    fi
    
    # Run tests with timeout
    if timeout 120 ./tests/test_runner.sh >/dev/null 2>&1; then
        log_success "Comprehensive tests passed"
    else
        log_error "Comprehensive tests failed"
        echo "Run './tests/test_runner.sh' to see detailed results"
    fi
}

check_installation_integrity() {
    log_info "Checking installation integrity..."
    
    # Test all installation profiles
    local profiles=("minimal" "standard" "full")
    
    for profile in "${profiles[@]}"; do
        if timeout 60 ./install.sh --dry-run install "$profile" >/dev/null 2>&1; then
            log_success "Installation profile '$profile' is valid"
        else
            log_warning "Installation profile '$profile' validation skipped (timeout or minor issue)"
        fi
    done
}

validate_documentation() {
    log_info "Validating documentation..."
    
    # Check if README exists and is not empty
    if [[ -f "README.md" ]] && [[ -s "README.md" ]]; then
        log_success "README.md exists and is not empty"
    else
        log_warning "README.md should exist and not be empty"
    fi
    
    # Check for installation instructions
    if [[ -f "README.md" ]] && grep -q "install" README.md; then
        log_success "README.md contains installation instructions"
    else
        log_warning "README.md should contain installation instructions"
    fi
    
    # Check for proper documentation structure
    if [[ -f "README.md" ]] && grep -q "^#" README.md; then
        log_success "README.md has proper heading structure"
    else
        log_warning "README.md should have proper heading structure"
    fi
}

check_security_compliance() {
    log_info "Checking security compliance..."
    
    # Check for sensitive files that shouldn't be committed
    local sensitive_files=(
        ".env"
        ".env.local"
        ".env.production"
        "id_rsa"
        "id_ed25519"
        "*.pem"
        "*.p12"
        "*.key"
        "secrets.yaml"
        "config.json"
    )
    
    local found_sensitive=false
    for pattern in "${sensitive_files[@]}"; do
        if find . -name "$pattern" -not -path "./.git/*" | grep -q .; then
            log_error "Sensitive file found: $pattern"
            found_sensitive=true
        fi
    done
    
    if [[ "$found_sensitive" == "false" ]]; then
        log_success "No sensitive files detected"
    fi
    
    # Check for hardcoded credentials
    local credential_patterns=(
        "password\s*=\s*['\"][^'\"]*['\"]"
        "secret\s*=\s*['\"][^'\"]*['\"]"
        "token\s*=\s*['\"][^'\"]*['\"]"
        "api_key\s*=\s*['\"][^'\"]*['\"]"
    )
    
    local found_credentials=false
    for pattern in "${credential_patterns[@]}"; do
        if grep -rE "$pattern" . --include="*.sh" --include="*.zsh" --include="*.yaml" --exclude-dir=".git" | grep -v "# Example" >/dev/null 2>&1; then
            log_error "Potential hardcoded credential found: $pattern"
            found_credentials=true
        fi
    done
    
    if [[ "$found_credentials" == "false" ]]; then
        log_success "No hardcoded credentials detected"
    fi
}

check_cross_platform_compatibility() {
    log_info "Checking cross-platform compatibility..."
    
    # Check for platform-specific paths
    local platform_paths=(
        "/usr/local/bin"
        "/opt/homebrew"
        "/home/"
        "C:\\"
        "\\Users\\"
    )
    
    local found_hardcoded=false
    for path in "${platform_paths[@]}"; do
        if grep -r "$path" . --include="*.sh" --include="*.zsh" --exclude-dir=".git" | grep -v "# Platform specific" >/dev/null 2>&1; then
            log_warning "Hardcoded platform path found: $path"
            found_hardcoded=true
        fi
    done
    
    if [[ "$found_hardcoded" == "false" ]]; then
        log_success "No hardcoded platform paths detected"
    fi
}

check_version_consistency() {
    log_info "Checking version consistency..."
    
    if [[ -f "VERSION" ]]; then
        local version
        version=$(cat VERSION)
        
        # Check if version is in semantic versioning format
        if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            log_success "Version format is valid: $version"
        else
            log_error "Version format is invalid: $version (expected: x.y.z or x.y.z-label)"
        fi
        
        # Check if version is referenced in other files
        if grep -q "$version" lib/version.sh 2>/dev/null; then
            log_success "Version is consistent across files"
        else
            log_warning "Version may not be consistent across all files"
        fi
    else
        log_warning "VERSION file not found"
    fi
}

check_commit_history() {
    log_info "Checking commit history..."
    
    # Check for commits that might indicate issues
    local recent_commits
    recent_commits=$(git log --oneline -10)
    
    # Check for fixup commits
    if echo "$recent_commits" | grep -q "fixup!"; then
        log_warning "Fixup commits detected - consider squashing"
    fi
    
    # Check for WIP commits
    if echo "$recent_commits" | grep -qi "wip\|work in progress"; then
        log_warning "WIP commits detected - ensure they're ready for push"
    fi
    
    # Check for merge commits on feature branches
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    if [[ "$current_branch" != "master" ]] && [[ "$current_branch" != "main" ]]; then
        if echo "$recent_commits" | grep -q "Merge branch"; then
            log_warning "Merge commits on feature branch - consider rebasing"
        fi
    fi
    
    log_success "Commit history check completed"
}

# Performance checks
check_repository_size() {
    log_info "Checking repository size..."
    
    # Check repository size
    local repo_size
    repo_size=$(du -sh . 2>/dev/null | cut -f1)
    
    log_info "Repository size: $repo_size"
    
    # Check for large files
    local large_files
    large_files=$(find . -type f -size +10M -not -path "./.git/*" 2>/dev/null)
    
    if [[ -n "$large_files" ]]; then
        log_warning "Large files detected:"
        echo "$large_files"
        echo "Consider using Git LFS for large files"
    else
        log_success "No large files detected"
    fi
}

# Main execution
main() {
    log_info "Starting pre-push validation for remote: $remote"
    echo
    
    # Change to repository root
    cd "$REPO_ROOT"
    
    # Run comprehensive tests
    run_comprehensive_tests
    echo
    
    # Check installation integrity
    check_installation_integrity
    echo
    
    # Validate documentation
    validate_documentation
    echo
    
    # Security checks
    check_security_compliance
    echo
    
    # Cross-platform compatibility
    check_cross_platform_compatibility
    echo
    
    # Version consistency
    check_version_consistency
    echo
    
    # Commit history
    check_commit_history
    echo
    
    # Performance checks
    check_repository_size
    echo
    
    # Summary
    if [[ $EXIT_CODE -eq 0 ]]; then
        log_success "All pre-push validations passed! ✅"
        echo "Ready to push to $remote"
    else
        log_error "Some pre-push validations failed! ❌"
        echo ""
        echo "Please fix the issues above before pushing."
        echo "You can run individual checks manually:"
        echo "  - Tests: ./tests/test_runner.sh"
        echo "  - Installation: ./install.sh --dry-run install standard"
        echo "  - Security: hooks/pre-commit"
        echo "  - Health: ./scripts/health-check.sh"
    fi
    
    exit $EXIT_CODE
}

# Run main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi